\section{Analisi e progettazione}
\subsection{Architettura}
Per lo sviluppo del gioco è stato utilizzato il design pattern \texttt{MVC} che permette la separazione della logica del gioco dal codice che si occupa della presentazione all'utente.

Il pattern consiste in 3 componenti principali:
\begin{itemize}
    \item \textbf{M}odel che implementa la logica di business del programma tramite le classi che espongono metodi utili ad accedere e manipolare i dati

    \item \textbf{V}iew che implementa l'interfaccia con cui l'utente interagirà. Ogni modifica che richiede l'intervento sui dati del \texttt{model} passerà attraverso il \texttt{controller}.

    \item \textbf{C}ontroller che si occupa di veicolare i messaggi inseriti dall'utente nella \texttt{view} per manipolare i dati contenuti nel \texttt{model}.
          Funge da tramite da \texttt{model} e \texttt{view} in quanto, sebbene la \texttt{view} sia in grado di leggere dati dal \texttt{model}, essa non è in grado di manipolarli.
\end{itemize}

\vspace{0.5cm}
Nell'architettura del progetto è stato fatto largo uso di quelle tecniche che contraddistinguono un linguaggio ad oggetti come \texttt{C\#}: l'\emph{incapsulamento}, il \emph{polimorfismo}, l'\emph{ereditarietà}, l'utilizzo di \emph{eccezioni} e l'utilizzo di \emph{classi generiche}.

\subsubsection{Model}
La struttura del \texttt{model} ruota interamente attorno alle \emph{note} (ossi i colpi che deve effettuare l'utente), come esse vengono generate e il mantenimento dei punti quando esse vengono colpite.

Ogni nota estende la classe astratta \texttt{INote} così che, tramite il meccanismo di \emph{upcasting} sia possibile riferirsi ad una generica classe che rappresenta una nota, la quale implementerà i metodi che la contraddistinguono.
Ogni nota in particolare è dotata di un punteggio che viene assegnato all'utente qualora esso la colpisse in modo perfetto, un'immagine da mostrare a schermo all'utente e la posizione a schermo (\emph{destra} o \emph{sinistra}).

La sequenza di note che l'utente deve colpire viene generata da un \emph{generatore di note}. Ogni generatore di note estende la classe astratta \texttt{INoteGenerator} che utilizza il design pattern \texttt{Observer}. Tale design pattern permette la comunicazione agli \emph{observer} delle nuove note generate.
La generazione di note avviene tramite l'utilizzo del metodo astratto \texttt{NextNote} la cui implementazione viene delegata all'utente.
Il metodo \texttt{NextNote} viene utilizzato da una routine interna che contiene il codice eseguito da un thread separato rispetto al flusso di esecuzione principale.
Tale thread si occupa di generare le note con la giusta cadenza temporale, basandosi sui \emph{BPM} raggiunti dall'utente.

Il punteggio dell'utente viene mantenuto nella classe \texttt{Game} che implementa l'interfaccia \texttt{IGame}. Tale classe espone un metodo utilizzato per comunicare che l'utente ha effettuato un colpo a vuoto ed un metodo per comunicare che l'utente ha colpito una certa nota con un determinato ritardo rispetto al colpo perfetto.
Tale classe inoltre si occupa di calcolare il punteggio totalizzato dall'utente e di generare un eccezione di tipo \texttt{GameEndedException} nel caso l'utente giunga alla condizione di fine gioco (20 colpi effettuati troppo presto o troppo tardi).
La classe \texttt{Game} si occupa inoltre di serializzare il punteggio dell'utente nell'apposito file \texttt{record.csv} e di deserializzare i record precedenti.

\subsubsection{View}
La struttura base della componente \texttt{View} è implementata interamente nella classe \texttt{MainView}. Tale classe, che implementa l'interfaccia \texttt{IMainView}, espone i metodi necessari per mostrare all'utente le schermate che compongono il gioco.

Ogni schermata di gioco è implementata tramite la classe \texttt{Panel} fornita dal framework \texttt{WinForms} e si occupa di gestire in modo autonomo i propri elementi grafici ed il proprio stato.
Nel caso sia necessario, tale schermata può comunicare con \texttt{MainView} contenendone un riferimento e, nel caso di \texttt{PlayingPanel} anche con \texttt{MainController}.

\vspace{0.5cm}
Particolare enfasi va posta sulla classe \texttt{PlayingPanel}: tale classe infatti si occupa di implementare in modo vero e proprio la schermata di gioco vista dall'utente.
Essa, implementando l'interfaccia \texttt{IObserver}, utilizza in modo diretto la classe \texttt{INoteGenerator} e mostra le nuove note generate all'utente inserendole in una lista generica di tipo \texttt{LinkedList} cosicchè sia possibile accedere all'elemento di testa e di coda.

Nel momento in cui un tasto viene premuto comunica in modo diretto a \texttt{MainController} dell'avvenuto colpimento di una nota o del colpo a vuoto.

Tale schermata inoltre mostra il punteggio raggiunto dall'utente, i colpi che l'utente può mancare prima che il gioco termini ed i BPM raggiunto.

\subsubsection{Controller}
La funzione di \texttt{controller} viene implementata dalla classe \texttt{MainController} che implementa l'interfaccia \texttt{IController}.
Tale classe espone tutti i metodi necessari per conoscere le informazioni contenute nella classe \texttt{Game} ed interagire con i metodi presenti nell'interfaccia \texttt{IGame}.

\newpage
\subsubsection{Utils ed Eccezioni}
Durante lo sviluppo del gioco si sono rese necessarie lo sviluppo di classi che svolgono funzioni che non sono direttamente imputabili a nessuna delle componenti del pattern \texttt{MVC}.
Tali classi sono quelle necessarie allo sviluppo del pattern \texttt{Obervable}, la rotazione di immagini, l'utilizzo di una tupla di 3 elementi editabile ecc.

Discorso del tutto analogo per le eccezioni che sono state create \emph{ad-hoc}.

\subsubsection{Versioning}
Lavorando in un team di 2 persone si è reso necessario l'utilizzo di un tool di versioning per permettere la sincronizzazione del codice ed evitare problemi di conflitti.

Si è fatto quindi largo uso del software di versioning \texttt{git} e della piattaforma \hyperlink{https://github.com}{github} soprattutto grazie all'eccellente integrazione in \emph{Visual Studio} tramite l'apposita estensione.
L'intero software è reperibile all'indirizzo \hyperlink{https://github.com/n28div/masterdrums}{n28div/masterdrums}.

\subsubsection{Librerie esterne}
Durante l'implementazione del gioco è stata utilizzata la libreria \hyperlink{https://github.com/naudio/NAudio}{NAudio} per riprodurre il suono del colpo sul rullante.
Tale libreria è opensource ed installabile tramite \texttt{nuget}.
\newpage
\subsection{Diagramma di robustezza}
Per illustrare il meccanismo di interazione tra i vari elementi del software, viene illustrato un diagramma di robustezza.

\vspace{1cm}
\begin{figure}[h]
    % \includegraphics[width=\linewidth]{diagrammi/diagramma_robustezza.png}
\end{figure}
\vspace{1.5cm}
All'avvio del gioco l'utente potrà eseguire una delle seguenti operazioni:
\begin{itemize}
    \item Visualizzare i record totalizzati dagli utenti nel gioco
    \item Chiudere il gioco
    \item Iniziare una nuova partita
\end{itemize}
\vspace{1cm}
Nel caso in cui l'utente decida di iniziare una nuova partita, dopo aver opportunamente inserito il nome, i BPM iniziali e scelto la modalità di gioco, verrà mostrata la schermata di gioco effettiva. Da tale schermata di gioco, durante l'esecuzione della partita premendo il tasto \texttt{ESC} della tastiera, l'utente avrà la possibilità di mettere in pausa la partita e di conseguenza di riprendere la partita o di abbandonarla, tornando al menù iniziale.

Se l'utente non abbandona la partita, ma essa termina tramite la condizione di fine gioco, il punteggio totalizzato viene memorizzato nell'apposito file \texttt{.csv}.
\vspace{0.5cm}

Nel caso in cui l'utente voglia visualizzare i record del gioco, verrà mostrata una schermata contenente i punteggi totalizzati dagli utenti, nel formato \texttt{Nome Punteggio}. Nel caso in cui non sia ancora stata effettuata la prima partita del gioco, la schermata non verrà mostrata e l'utente verrà opportunamente avvisato della mancanza di risultati.

\newpage
\subsection{Diagramma UML delle classi}
\vspace{2cm}
\begin{figure}[h]
    % \includegraphics[width=\linewidth]{uml/complete.png}
\end{figure}

\newpage
\subsection{Model}
\begin{figure}[h]
    % \includegraphics[width=\linewidth]{uml/notes.png}
\end{figure}
\vspace{1cm}

Nell'immagine posta sopra, viene descritta l'architettura mediante schema UML della parte riguardante le note e il generatore di note. Come visto nella specifica del problema, le modalità proposte dal gioco sono due, e dipendono dal modo in cui vengono generate le note. Nella modalità \emph{combinazioni casuali} le note vengono generate in maniera puramente casuale, senza nessun controllo sulla loro posizione, mentre nella modalità \emph{mani alternate} vengono generate note con posizione (destra e sinistra) alternate tra loro. Questo avviene grazie ai due generatori di note descritti nell'immagine sopra riportata: entrambi i generatori di note implementano la classe astratta \texttt{INoteGenerator}, ed eseguono l'override dei due metodi \texttt{ToString()} e \texttt{NextNote()}. Molta attenzione va posta in particolare nel metodo \texttt{NextNote()}, in quanto nella modalità \emph{mani alternate} la prossima nota dovrà per forza essere nella posizione opposta rispetto all'ultima nota generata.

É importante inoltre notare come \texttt{INoteGenerator} estende la classe astratta \texttt{ISubject}, necessaria per rendere il generatore di note come l'oggetto osservato dai vari observer, come descritto nell'architettura del design pattern \texttt{Observer}.

Per quanto riguarda le note invece, si osservi come esse risultino tutte derivanti dalla classe astratta \texttt{INote}, della quale eseguono l'override dei metodi \texttt{HitPoint()} e \texttt{Image()}. Ciascuna tipologia di nota avrà infatti una sua caratterizzazione per quello che riguarda il punteggio e l'immagine che la rappresenterà nel pannello di gioco.

\vspace{1cm}
\begin{figure}[h]
    % \includegraphics[width=\linewidth]{uml/game.png}
\end{figure}
La classe \texttt{Game} è la classe che si occupa di mantenere il punteggio dell'utente, di aumentare i BPM e di salvare il punteggio nel file \texttt{csv}.
Come si può notare dal diagramma UML tale classe implementa l'interfaccia \texttt{IGame} e ne effettua l'\emph{override} dei metodi \texttt{Hit()}, che rappresenta il metodo che comunica al gioco un colpo vuoto, \texttt{Hit(note, deltaT)} che rappresenta il colpo andato a segno sulla nota \texttt{note} dopo un tempo di \texttt{deltaT} $ms$ dal tempo di colpo perfetto ed infine il metodo \texttt{SerializeScore} che si occupa di salvare il punteggio nel file.

La classe \texttt{Game} inoltre espone il metodo statico \texttt{LoadBestResults} che si occupa di leggere dal file \texttt{csv} i punteggi effettuati precedentemente.

\newpage
\subsection{Controller}
\begin{figure}[h]
    % \includegraphics[width=\linewidth]{uml/controller.png}
\end{figure}
La struttura del controller è piuttosto semplice: la classe concreta \texttt{MainController} implementa l'interfaccia \texttt{IController} che espone metodi utili ad interagire con le classi che implementano l'interfaccia \texttt{IGame}.
La classe \texttt{MainController} contiene inoltre al suo interno un riferimento alla \emph{view principale} (\texttt{MainView}) così da poter comunicare di reagire a determinati eventi.

\newpage
\subsection{View}
\begin{figure}[h!]
    % \includegraphics[width=\linewidth]{uml/view.png}
\end{figure}
La componente \emph{view} del progetto è principalmente gestita dalla classe concreta \texttt{MainView} che implementa l'interfaccia \texttt{IMainView} e funge da \emph{"controller"} per le altre viste, implementate sotto forma di \texttt{Panel}.
La classe \texttt{MainView} espone metodi per attivare o nascondere le viste che compongono il gioco (menù iniziale, schermata di pausa ecc.) e contiene metodi privati per creare ed inizializzare tali viste di modo che le dimensioni di esse siano dipendenti dalla dimensione dello schermo dell'utente (il gioco viene presentato a schermo intero).

\vspace{0.5cm}
Particolare enfasi va posta sulla classe concreta \texttt{PlayingPanel}: tale classe infatti rappresenta un \emph{Observer} della classe \texttt{INoteGeneretor}.
Al suo interno inoltre è presente il metodo \texttt{PaintObjects(object sender, PaintEventArgs e)} che viene chiamato periodicamente e si occupa di disegnare a schermo gli \emph{sprite} che compongono il gioco.
Il pannello di gioco infatti gestisce tutti gli elementi grafici disegnandoli in una \texttt{PictureBox} che copre l'intero schermo dell'utente. Così facendo è possibile gestire in maniere semplice ed efficiente la sovrapposizione di oggetti sullo schermo.

Di particolare importanza è anche il metodo \texttt{DrawNotes} che tramite trasformazioni geometriche e trigonometriche si occupa di disegnare a schermo le note e di calcolare la loro posizione futura.