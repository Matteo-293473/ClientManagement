\section{Analisi e progettazione}
\subsection{Architettura}

Per lo sviluppo del software, sono state create le classi commissione e cliente che sono dei semplici modelli
e, al fine di avere un basso accoppiamento (loose coupling), si è creata una nuova classe che va a 
separare la parte dello storage dei dati. 
Per farlo, si è optato per l'uso di due dizionari, il primo composto da un numero intero come chiave e l'oggetto cliente come valore associato e 
l'altro definito da un intero che, oltre a funzionare come chiave, rappresenta anche il cliente attraverso il primo dizionario e come valore una
lista di commissioni.  
 \vspace{0.5cm}
 Per l'architettura sono stati usati 3 pattern:
\begin{itemize}
    \item Singleton, pattern creazionale che garantisce la creazione di una e una sola istanza della classe.  
    Viene usata durante la fase di salvataggio (in modo da richiamare sempre la stessa istanza) e per la gestione
    dei dati interni al programma. 
    Il singleton ci serve per poter implementare un'interfaccia o per estendere un'altra classe avendo i vantaggi di una classe statica.\\
    Durante la gestione dei dati interni implementiamo il singleton per poter poi aggiungere un altro pattern che è
    l'Observer. 
    \item Composite, pattern strutturale conferisce al programma flessibilità ed estensibilità. Consente di creare nuovi oggetti annidati basati 
    su altri già esistenti. Nel nostro caso, utile nella fase di rappresentazione dei dati per comporre le entry all'interno delle listview.

    \item Observer, pattern comportamentale che consente il sistema basato su eventi. \\
    Viene usato per notificare a tutte le classi dedite alla rappresentazione che son 
    stati apportati cambiamenti in locale e quindi devono essere aggiornate con dati recenti. 
    Oltre all'aspetto grafico, con questo pattern è stato possibile applicare un controllo in fase di uscita:
    usufruiamo della notifica per indicare che c'è stato un cambiamento e che quindi è presente la necessità di salvare.

    
    L'approccio usato è di tipo pull, ovvero la classe che notifica non invia dati ma il solo segnale, saranno
    poi le classi notificate ad occuparsi di recuperare i dati attraverso metodi esposti
    da parte della classe dedicata alla memoria. \\
    Il tipo di approccio pull permette una maggiore flessibilità, ogni observer decide cosa 
    richiedere. \\
    In genere si usa questo approccio quando ci sono diversi tipi di observer.
    In virtù di questo pattern si è riusciti a separare dati e modelli.
\end{itemize}

\vspace{0.5cm}
Nell'archiettura del progetto è stato fatto uso di quelle tecniche che contraddistinguono un linguaggio
ad oggetti come \texttt{C\#}: Incapsulemento, ereditarietà, polimorfismo, eccezioni.

 \vspace{0.5cm}
 polimorfismo
 \vspace{0.5cm}
 override e overload
 \vspace{0.5cm}



Al fine di non sporcare le classi e mantenere ordine all'interno del codice, le logiche vengono delegate ad altre classi handler.
Si è poi fatto uso dell'ereditarietà tra i vari handler, poichè alcune classi differivano solo di pochi metodi: 
La classe \texttt{HandlerCommissioni} che funge da classe base, viene estesa dalle classi figlie \texttt{HandlerCommissioniTotali},
\texttt{HandlerCommissioniInScadenza} e \texttt{HandlerCommissioniDaFare}.

Sono state aggiunte alcune classi statiche, ad esempio quelle per il controllo degli input, al fine di non ripetere codice
inutilmente

\subsubsection{Cliente}
La classe \texttt{Cliente} è composta da diverse proprietà, membri che forniscono un meccanismo flessibile per leggere, 
scrivere o calcolare il valore di un campo privato, che definiscono il cliente. Troviamo Nome, Cognome, Email e Numero. \\
La classe implementa l'interfaccia IComponent e quindi realizza il metodo ToArrayString così da poter applicare il pattern
composite.

\subsubsection{Commissione}
\texttt{Commissione} è descritta da IdCommissione, Descrizione, TaskCompletato e da una Scadenza. È presenta anche un attributo
statico che permette identificare in modo univoco ciascuna commissione. Usufruendo dell'overload poi, sono presenti due costruttori,
uno utile nell'inserimento di una nuova commissione e l'altro necessario quando carichiamo le commissioni da file, in questo modo
abbiamo più controllo sulla variabile globale statica. Come per la classe \texttt{Cliente}, anche qui viene implementata l'interfaccia
IComponent.

\subsubsection{DatiLocali}
La gestione dei dati in locale è delegata alla classe \texttt{DatiLocali}, dove troviamo applicati i due pattern, \textbf{Singleton} e 
\textbf{Observer}. Quest'ultimo è applicato implementando l'interfaccia \texttt{IObserver} e estendendo la classe \texttt{Subject}.
Era necessaria una classe che avesse un'unica istanza, così da non andare a generare istanze con dati diversi, ma che potesse comunque 
estendere una classe o implementare un'interfaccia. In questo caso ci viene incontro il Singleton, che appunto rende possibili entrambe le richieste blindando il costruttore, 
rendendolo richiamabile una sola volta attraverso il metodo \texttt{GetInstance()}. Costruttore che contiene l'iscrizione all'evento




\subsubsection{Model}
La struttura del \texttt{model} ruota interamente attorno alle \emph{note} (ossi i colpi che deve effettuare l'utente), come esse vengono generate e il mantenimento dei punti quando esse vengono colpite.

Ogni nota estende la classe astratta \texttt{INote} così che, tramite il meccanismo di \emph{upcasting} sia possibile riferirsi ad una generica classe che rappresenta una nota, la quale implementerà i metodi che la contraddistinguono.
Ogni nota in particolare è dotata di un punteggio che viene assegnato all'utente qualora esso la colpisse in modo perfetto, un'immagine da mostrare a schermo all'utente e la posizione a schermo (\emph{destra} o \emph{sinistra}).

La sequenza di note che l'utente deve colpire viene generata da un \emph{generatore di note}. Ogni generatore di note estende la classe astratta \texttt{INoteGenerator} che utilizza il design pattern \texttt{Observer}. Tale design pattern permette la comunicazione agli \emph{observer} delle nuove note generate.
La generazione di note avviene tramite l'utilizzo del metodo astratto \texttt{NextNote} la cui implementazione viene delegata all'utente.
Il metodo \texttt{NextNote} viene utilizzato da una routine interna che contiene il codice eseguito da un thread separato rispetto al flusso di esecuzione principale.
Tale thread si occupa di generare le note con la giusta cadenza temporale, basandosi sui \emph{BPM} raggiunti dall'utente.

Il punteggio dell'utente viene mantenuto nella classe \texttt{Game} che implementa l'interfaccia \texttt{IGame}. Tale classe espone un metodo utilizzato per comunicare che l'utente ha effettuato un colpo a vuoto ed un metodo per comunicare che l'utente ha colpito una certa nota con un determinato ritardo rispetto al colpo perfetto.
Tale classe inoltre si occupa di calcolare il punteggio totalizzato dall'utente e di generare un eccezione di tipo \texttt{GameEndedException} nel caso l'utente giunga alla condizione di fine gioco (20 colpi effettuati troppo presto o troppo tardi).
La classe \texttt{Game} si occupa inoltre di serializzare il punteggio dell'utente nell'apposito file \texttt{record.csv} e di deserializzare i record precedenti.

\subsubsection{View}
La struttura base della componente \texttt{View} è implementata interamente nella classe \texttt{MainView}. Tale classe, che implementa l'interfaccia \texttt{IMainView}, espone i metodi necessari per mostrare all'utente le schermate che compongono il gioco.

Ogni schermata di gioco è implementata tramite la classe \texttt{Panel} fornita dal framework \texttt{WinForms} e si occupa di gestire in modo autonomo i propri elementi grafici ed il proprio stato.
Nel caso sia necessario, tale schermata può comunicare con \texttt{MainView} contenendone un riferimento e, nel caso di \texttt{PlayingPanel} anche con \texttt{MainController}.

\vspace{0.5cm}
Particolare enfasi va posta sulla classe \texttt{PlayingPanel}: tale classe infatti si 
occupa di implementare in modo vero e proprio la schermata di gioco vista dall'utente.
Essa, implementando l'interfaccia \texttt{IObserver}, utilizza in modo diretto la classe \texttt{INoteGenerator} e mostra le nuove note generate all'utente inserendole in una lista generica di tipo \texttt{LinkedList} cosicchè sia possibile accedere all'elemento di testa e di coda.

Nel momento in cui un tasto viene premuto comunica in modo diretto a \texttt{MainController} dell'avvenuto colpimento di una nota o del colpo a vuoto.

Tale schermata inoltre mostra il punteggio raggiunto dall'utente, i colpi che l'utente può mancare prima che il gioco termini ed i BPM raggiunto.

\subsubsection{Controller}
La funzione di \texttt{controller} viene implementata dalla classe \texttt{MainController} che implementa l'interfaccia \texttt{IController}.
Tale classe espone tutti i metodi necessari per conoscere le informazioni contenute nella classe \texttt{Game} ed interagire con i metodi presenti nell'interfaccia \texttt{IGame}.

\newpage
\subsubsection{Utils ed Eccezioni}
Durante lo sviluppo del gioco si sono rese necessarie lo sviluppo di classi che svolgono funzioni che non sono direttamente imputabili a nessuna delle componenti del pattern \texttt{MVC}.
Tali classi sono quelle necessarie allo sviluppo del pattern \texttt{Obervable}, la rotazione di immagini, l'utilizzo di una tupla di 3 elementi editabile ecc.

Discorso del tutto analogo per le eccezioni che sono state create \emph{ad-hoc}.

\subsubsection{Versioning}
Lavorando in un team di 2 persone si è reso necessario l'utilizzo di un tool di versioning per permettere la sincronizzazione del codice ed evitare problemi di conflitti.

Si è fatto quindi largo uso del software di versioning \texttt{git} e della piattaforma \hyperlink{https://github.com}{github} soprattutto grazie all'eccellente integrazione in \emph{Visual Studio} tramite l'apposita estensione.
L'intero software è reperibile all'indirizzo \hyperlink{https://github.com/n28div/masterdrums}{n28div/masterdrums}.

\subsubsection{Librerie esterne}
Durante l'implementazione del gioco è stata utilizzata la libreria \hyperlink{https://github.com/naudio/NAudio}{NAudio} per riprodurre il suono del colpo sul rullante.
Tale libreria è opensource ed installabile tramite \texttt{nuget}.
\newpage
\subsection{Diagramma di robustezza}
Per illustrare il meccanismo di interazione tra i vari elementi del software, viene illustrato un diagramma di robustezza.

\vspace{1cm}
\begin{figure}[h]
    % \includegraphics[width=\linewidth]{diagrammi/diagramma_robustezza.png}
\end{figure}
\vspace{1.5cm}
All'avvio del gioco l'utente potrà eseguire una delle seguenti operazioni:
\begin{itemize}
    \item Visualizzare i record totalizzati dagli utenti nel gioco
    \item Chiudere il gioco
    \item Iniziare una nuova partita
\end{itemize}
\vspace{1cm}
Nel caso in cui l'utente decida di iniziare una nuova partita, dopo aver opportunamente inserito il nome, i BPM iniziali e scelto la modalità di gioco, verrà mostrata la schermata di gioco effettiva. Da tale schermata di gioco, durante l'esecuzione della partita premendo il tasto \texttt{ESC} della tastiera, l'utente avrà la possibilità di mettere in pausa la partita e di conseguenza di riprendere la partita o di abbandonarla, tornando al menù iniziale.

Se l'utente non abbandona la partita, ma essa termina tramite la condizione di fine gioco, il punteggio totalizzato viene memorizzato nell'apposito file \texttt{.csv}.
\vspace{0.5cm}

Nel caso in cui l'utente voglia visualizzare i record del gioco, verrà mostrata una schermata contenente i punteggi totalizzati dagli utenti, nel formato \texttt{Nome Punteggio}. Nel caso in cui non sia ancora stata effettuata la prima partita del gioco, la schermata non verrà mostrata e l'utente verrà opportunamente avvisato della mancanza di risultati.

\newpage
\subsection{Diagramma UML delle classi}
\vspace{2cm}
\begin{figure}[h]
    % \includegraphics[width=\linewidth]{uml/complete.png}
\end{figure}

\newpage
\subsection{Model}
\begin{figure}[h]
    % \includegraphics[width=\linewidth]{uml/notes.png}
\end{figure}
\vspace{1cm}

Nell'immagine posta sopra, viene descritta l'architettura mediante schema UML della parte riguardante le note e il generatore di note. Come visto nella specifica del problema, le modalità proposte dal gioco sono due, e dipendono dal modo in cui vengono generate le note. Nella modalità \emph{combinazioni casuali} le note vengono generate in maniera puramente casuale, senza nessun controllo sulla loro posizione, mentre nella modalità \emph{mani alternate} vengono generate note con posizione (destra e sinistra) alternate tra loro. Questo avviene grazie ai due generatori di note descritti nell'immagine sopra riportata: entrambi i generatori di note implementano la classe astratta \texttt{INoteGenerator}, ed eseguono l'override dei due metodi \texttt{ToString()} e \texttt{NextNote()}. Molta attenzione va posta in particolare nel metodo \texttt{NextNote()}, in quanto nella modalità \emph{mani alternate} la prossima nota dovrà per forza essere nella posizione opposta rispetto all'ultima nota generata.

É importante inoltre notare come \texttt{INoteGenerator} estende la classe astratta \texttt{ISubject}, necessaria per rendere il generatore di note come l'oggetto osservato dai vari observer, come descritto nell'architettura del design pattern \texttt{Observer}.

Per quanto riguarda le note invece, si osservi come esse risultino tutte derivanti dalla classe astratta \texttt{INote}, della quale eseguono l'override dei metodi \texttt{HitPoint()} e \texttt{Image()}. Ciascuna tipologia di nota avrà infatti una sua caratterizzazione per quello che riguarda il punteggio e l'immagine che la rappresenterà nel pannello di gioco.

\vspace{1cm}
\begin{figure}[h]
    % \includegraphics[width=\linewidth]{uml/game.png}
\end{figure}
La classe \texttt{Game} è la classe che si occupa di mantenere il punteggio dell'utente, di aumentare i BPM e di salvare il punteggio nel file \texttt{csv}.
Come si può notare dal diagramma UML tale classe implementa l'interfaccia \texttt{IGame} e ne effettua l'\emph{override} dei metodi \texttt{Hit()}, che rappresenta il metodo che comunica al gioco un colpo vuoto, \texttt{Hit(note, deltaT)} che rappresenta il colpo andato a segno sulla nota \texttt{note} dopo un tempo di \texttt{deltaT} $ms$ dal tempo di colpo perfetto ed infine il metodo \texttt{SerializeScore} che si occupa di salvare il punteggio nel file.

La classe \texttt{Game} inoltre espone il metodo statico \texttt{LoadBestResults} che si occupa di leggere dal file \texttt{csv} i punteggi effettuati precedentemente.

\newpage
\subsection{Controller}
\begin{figure}[h]
    % \includegraphics[width=\linewidth]{uml/controller.png}
\end{figure}
La struttura del controller è piuttosto semplice: la classe concreta \texttt{MainController} implementa l'interfaccia \texttt{IController} che espone metodi utili ad interagire con le classi che implementano l'interfaccia \texttt{IGame}.
La classe \texttt{MainController} contiene inoltre al suo interno un riferimento alla \emph{view principale} (\texttt{MainView}) così da poter comunicare di reagire a determinati eventi.

\newpage
\subsection{View}
\begin{figure}[h!]
    % \includegraphics[width=\linewidth]{uml/view.png}
\end{figure}
La componente \emph{view} del progetto è principalmente gestita dalla classe concreta \texttt{MainView} che implementa l'interfaccia \texttt{IMainView} e funge da \emph{"controller"} per le altre viste, implementate sotto forma di \texttt{Panel}.
La classe \texttt{MainView} espone metodi per attivare o nascondere le viste che compongono il gioco (menù iniziale, schermata di pausa ecc.) e contiene metodi privati per creare ed inizializzare tali viste di modo che le dimensioni di esse siano dipendenti dalla dimensione dello schermo dell'utente (il gioco viene presentato a schermo intero).

\vspace{0.5cm}
Particolare enfasi va posta sulla classe concreta \texttt{PlayingPanel}: tale classe infatti rappresenta un \emph{Observer} della classe \texttt{INoteGeneretor}.
Al suo interno inoltre è presente il metodo \texttt{PaintObjects(object sender, PaintEventArgs e)} che viene chiamato periodicamente e si occupa di disegnare a schermo gli \emph{sprite} che compongono il gioco.
Il pannello di gioco infatti gestisce tutti gli elementi grafici disegnandoli in una \texttt{PictureBox} che copre l'intero schermo dell'utente. Così facendo è possibile gestire in maniere semplice ed efficiente la sovrapposizione di oggetti sullo schermo.

Di particolare importanza è anche il metodo \texttt{DrawNotes} che tramite trasformazioni geometriche e trigonometriche si occupa di disegnare a schermo le note e di calcolare la loro posizione futura.